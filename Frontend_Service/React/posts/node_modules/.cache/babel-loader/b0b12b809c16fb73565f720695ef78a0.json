{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport isPromise from 'is-promise';\nimport SubmissionError from './SubmissionError';\n\nvar isSubmissionError = function isSubmissionError(error) {\n  return error && error.name === SubmissionError.name;\n};\n\nvar mergeErrors = function mergeErrors(_ref) {\n  var asyncErrors = _ref.asyncErrors,\n      syncErrors = _ref.syncErrors;\n  return asyncErrors && typeof asyncErrors.merge === 'function' ? asyncErrors.merge(syncErrors).toJS() : _extends({}, asyncErrors, {}, syncErrors);\n};\n\nvar isImmutableList;\n\ntry {\n  // ImmutableJS isList implementation if available\n  // eslint-disable-next-line import/no-extraneous-dependencies\n  var _require = require('immutable'),\n      List = _require.List;\n\n  isImmutableList = List.isList;\n} catch (err) {\n  isImmutableList = function isImmutableList(maybeList) {\n    return false;\n  };\n} // fields may be an Immutable List which cannot be spread\n// convert the fields to an array if necessary\n\n\nvar makeFieldsArray = function makeFieldsArray(fields) {\n  return isImmutableList(fields) ? fields.toArray() : fields;\n};\n\nvar executeSubmit = function executeSubmit(submit, fields, props) {\n  var dispatch = props.dispatch,\n      submitAsSideEffect = props.submitAsSideEffect,\n      onSubmitFail = props.onSubmitFail,\n      onSubmitSuccess = props.onSubmitSuccess,\n      startSubmit = props.startSubmit,\n      stopSubmit = props.stopSubmit,\n      setSubmitFailed = props.setSubmitFailed,\n      setSubmitSucceeded = props.setSubmitSucceeded,\n      values = props.values;\n  fields = makeFieldsArray(fields);\n  var result;\n\n  try {\n    result = submit(values, dispatch, props);\n  } catch (submitError) {\n    var error = isSubmissionError(submitError) ? submitError.errors : undefined;\n    stopSubmit(error);\n    setSubmitFailed.apply(void 0, fields);\n\n    if (onSubmitFail) {\n      onSubmitFail(error, dispatch, submitError, props);\n    }\n\n    if (error || onSubmitFail) {\n      // if you've provided an onSubmitFail callback, don't re-throw the error\n      return error;\n    } else {\n      throw submitError;\n    }\n  }\n\n  if (submitAsSideEffect) {\n    if (result) {\n      dispatch(result);\n    }\n  } else {\n    if (isPromise(result)) {\n      startSubmit();\n      return result.then(function (submitResult) {\n        stopSubmit();\n        setSubmitSucceeded();\n\n        if (onSubmitSuccess) {\n          onSubmitSuccess(submitResult, dispatch, props);\n        }\n\n        return submitResult;\n      }, function (submitError) {\n        var error = isSubmissionError(submitError) ? submitError.errors : undefined;\n        stopSubmit(error);\n        setSubmitFailed.apply(void 0, fields);\n\n        if (onSubmitFail) {\n          onSubmitFail(error, dispatch, submitError, props);\n        }\n\n        if (error || onSubmitFail) {\n          // if you've provided an onSubmitFail callback, don't re-throw the error\n          return error;\n        } else {\n          throw submitError;\n        }\n      });\n    } else {\n      setSubmitSucceeded();\n\n      if (onSubmitSuccess) {\n        onSubmitSuccess(result, dispatch, props);\n      }\n    }\n  }\n\n  return result;\n};\n\nvar handleSubmit = function handleSubmit(submit, props, valid, asyncValidate, fields) {\n  var dispatch = props.dispatch,\n      onSubmitFail = props.onSubmitFail,\n      setSubmitFailed = props.setSubmitFailed,\n      syncErrors = props.syncErrors,\n      asyncErrors = props.asyncErrors,\n      touch = props.touch,\n      persistentSubmitErrors = props.persistentSubmitErrors;\n  fields = makeFieldsArray(fields);\n  touch.apply(void 0, fields); // mark all fields as touched\n\n  if (valid || persistentSubmitErrors) {\n    var asyncValidateResult = asyncValidate && asyncValidate();\n\n    if (asyncValidateResult) {\n      return asyncValidateResult.then(function (asyncErrors) {\n        if (asyncErrors) {\n          throw asyncErrors;\n        }\n\n        return executeSubmit(submit, fields, props);\n      })[\"catch\"](function (asyncErrors) {\n        setSubmitFailed.apply(void 0, fields);\n\n        if (onSubmitFail) {\n          onSubmitFail(asyncErrors, dispatch, null, props);\n        }\n\n        return Promise.reject(asyncErrors);\n      });\n    } else {\n      return executeSubmit(submit, fields, props);\n    }\n  } else {\n    setSubmitFailed.apply(void 0, fields);\n    var errors = mergeErrors({\n      asyncErrors: asyncErrors,\n      syncErrors: syncErrors\n    });\n\n    if (onSubmitFail) {\n      onSubmitFail(errors, dispatch, null, props);\n    }\n\n    return errors;\n  }\n};\n\nexport default handleSubmit;","map":{"version":3,"sources":["C:/Users/skybl/TIL/Frontend_Service/React/posts/node_modules/redux-form/es/handleSubmit.js"],"names":["_extends","isPromise","SubmissionError","isSubmissionError","error","name","mergeErrors","_ref","asyncErrors","syncErrors","merge","toJS","isImmutableList","_require","require","List","isList","err","maybeList","makeFieldsArray","fields","toArray","executeSubmit","submit","props","dispatch","submitAsSideEffect","onSubmitFail","onSubmitSuccess","startSubmit","stopSubmit","setSubmitFailed","setSubmitSucceeded","values","result","submitError","errors","undefined","apply","then","submitResult","handleSubmit","valid","asyncValidate","touch","persistentSubmitErrors","asyncValidateResult","Promise","reject"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/extends\";\r\nimport isPromise from 'is-promise';\r\nimport SubmissionError from './SubmissionError';\r\n\r\nvar isSubmissionError = function isSubmissionError(error) {\r\n  return error && error.name === SubmissionError.name;\r\n};\r\n\r\nvar mergeErrors = function mergeErrors(_ref) {\r\n  var asyncErrors = _ref.asyncErrors,\r\n      syncErrors = _ref.syncErrors;\r\n  return asyncErrors && typeof asyncErrors.merge === 'function' ? asyncErrors.merge(syncErrors).toJS() : _extends({}, asyncErrors, {}, syncErrors);\r\n};\r\n\r\nvar isImmutableList;\r\n\r\ntry {\r\n  // ImmutableJS isList implementation if available\r\n  // eslint-disable-next-line import/no-extraneous-dependencies\r\n  var _require = require('immutable'),\r\n      List = _require.List;\r\n\r\n  isImmutableList = List.isList;\r\n} catch (err) {\r\n  isImmutableList = function isImmutableList(maybeList) {\r\n    return false;\r\n  };\r\n} // fields may be an Immutable List which cannot be spread\r\n// convert the fields to an array if necessary\r\n\r\n\r\nvar makeFieldsArray = function makeFieldsArray(fields) {\r\n  return isImmutableList(fields) ? fields.toArray() : fields;\r\n};\r\n\r\nvar executeSubmit = function executeSubmit(submit, fields, props) {\r\n  var dispatch = props.dispatch,\r\n      submitAsSideEffect = props.submitAsSideEffect,\r\n      onSubmitFail = props.onSubmitFail,\r\n      onSubmitSuccess = props.onSubmitSuccess,\r\n      startSubmit = props.startSubmit,\r\n      stopSubmit = props.stopSubmit,\r\n      setSubmitFailed = props.setSubmitFailed,\r\n      setSubmitSucceeded = props.setSubmitSucceeded,\r\n      values = props.values;\r\n  fields = makeFieldsArray(fields);\r\n  var result;\r\n\r\n  try {\r\n    result = submit(values, dispatch, props);\r\n  } catch (submitError) {\r\n    var error = isSubmissionError(submitError) ? submitError.errors : undefined;\r\n    stopSubmit(error);\r\n    setSubmitFailed.apply(void 0, fields);\r\n\r\n    if (onSubmitFail) {\r\n      onSubmitFail(error, dispatch, submitError, props);\r\n    }\r\n\r\n    if (error || onSubmitFail) {\r\n      // if you've provided an onSubmitFail callback, don't re-throw the error\r\n      return error;\r\n    } else {\r\n      throw submitError;\r\n    }\r\n  }\r\n\r\n  if (submitAsSideEffect) {\r\n    if (result) {\r\n      dispatch(result);\r\n    }\r\n  } else {\r\n    if (isPromise(result)) {\r\n      startSubmit();\r\n      return result.then(function (submitResult) {\r\n        stopSubmit();\r\n        setSubmitSucceeded();\r\n\r\n        if (onSubmitSuccess) {\r\n          onSubmitSuccess(submitResult, dispatch, props);\r\n        }\r\n\r\n        return submitResult;\r\n      }, function (submitError) {\r\n        var error = isSubmissionError(submitError) ? submitError.errors : undefined;\r\n        stopSubmit(error);\r\n        setSubmitFailed.apply(void 0, fields);\r\n\r\n        if (onSubmitFail) {\r\n          onSubmitFail(error, dispatch, submitError, props);\r\n        }\r\n\r\n        if (error || onSubmitFail) {\r\n          // if you've provided an onSubmitFail callback, don't re-throw the error\r\n          return error;\r\n        } else {\r\n          throw submitError;\r\n        }\r\n      });\r\n    } else {\r\n      setSubmitSucceeded();\r\n\r\n      if (onSubmitSuccess) {\r\n        onSubmitSuccess(result, dispatch, props);\r\n      }\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nvar handleSubmit = function handleSubmit(submit, props, valid, asyncValidate, fields) {\r\n  var dispatch = props.dispatch,\r\n      onSubmitFail = props.onSubmitFail,\r\n      setSubmitFailed = props.setSubmitFailed,\r\n      syncErrors = props.syncErrors,\r\n      asyncErrors = props.asyncErrors,\r\n      touch = props.touch,\r\n      persistentSubmitErrors = props.persistentSubmitErrors;\r\n  fields = makeFieldsArray(fields);\r\n  touch.apply(void 0, fields); // mark all fields as touched\r\n\r\n  if (valid || persistentSubmitErrors) {\r\n    var asyncValidateResult = asyncValidate && asyncValidate();\r\n\r\n    if (asyncValidateResult) {\r\n      return asyncValidateResult.then(function (asyncErrors) {\r\n        if (asyncErrors) {\r\n          throw asyncErrors;\r\n        }\r\n\r\n        return executeSubmit(submit, fields, props);\r\n      })[\"catch\"](function (asyncErrors) {\r\n        setSubmitFailed.apply(void 0, fields);\r\n\r\n        if (onSubmitFail) {\r\n          onSubmitFail(asyncErrors, dispatch, null, props);\r\n        }\r\n\r\n        return Promise.reject(asyncErrors);\r\n      });\r\n    } else {\r\n      return executeSubmit(submit, fields, props);\r\n    }\r\n  } else {\r\n    setSubmitFailed.apply(void 0, fields);\r\n    var errors = mergeErrors({\r\n      asyncErrors: asyncErrors,\r\n      syncErrors: syncErrors\r\n    });\r\n\r\n    if (onSubmitFail) {\r\n      onSubmitFail(errors, dispatch, null, props);\r\n    }\r\n\r\n    return errors;\r\n  }\r\n};\r\n\r\nexport default handleSubmit;"]},"metadata":{},"sourceType":"module"}